{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AutoDispose","text":"<p>AutoDispose is an RxJava 2+ tool for automatically binding the execution of RxJava streams to a provided scope via disposal/cancellation.</p>"},{"location":"#overview","title":"Overview","text":"<p>Often (especially in mobile applications), Rx subscriptions need to stop in response to some event (for instance, when Activity#onStop() executes in an Android app). In order to support this common scenario in RxJava 2, we built AutoDispose.</p> <p>The idea is simple: construct your chain like any other, and then at subscription you simply drop in the relevant factory call + method for that type as a converter. In everyday use, it  usually looks like this:</p> <pre><code>myObservable\n.doStuff()\n.as(autoDisposable(this))   // The magic\n.subscribe(s -&gt; ...);\n</code></pre> <p>By doing this, you will automatically unsubscribe from <code>myObservable</code> as indicated by your scope - this helps prevent many classes of errors when an observable emits an item, but the actions taken in the subscription are no longer valid. For instance, if a network request comes back after a  UI has already been torn down, the UI can\u2019t be updated - this pattern prevents this type of bug.</p>"},{"location":"#autodisposable","title":"<code>autoDisposable()</code>","text":"<p>The main entry point is via static factory <code>autoDisposable()</code> methods in the <code>AutoDispose</code> class. There are two overloads: <code>Completable</code> and <code>ScopeProvider</code>. They return an <code>AutoDisposeConverter</code> object that implements all the RxJava <code>Converter</code> interfaces for use with the <code>as()</code> operator in RxJava types.</p>"},{"location":"#completable-as-a-scope","title":"Completable (as a scope)","text":"<p>The <code>Completable</code> semantic is modeled after the <code>takeUntil()</code> operator, which accepts an <code>Observable</code> whose first emission is used as a notification to signal completion. This is logically the behavior of a <code>Single</code>, so we choose to make that explicit. Since the type doesn\u2019t matter, we simplify this further to just be a <code>Completable</code>, where the scope-end emission is just a completion event. All scopes in AutoDispose eventually resolve to a <code>Completable</code> that emits the end-of-scope notification in <code>onComplete</code>. <code>onError</code> will pass through to the underlying subscription.</p>"},{"location":"#scopeprovider","title":"ScopeProvider","text":"<pre><code>public interface ScopeProvider {\nCompletableSource requestScope() throws Exception;\n}\n</code></pre> <p><code>ScopeProvider</code> is an abstraction that allows objects to expose and control and provide their own scopes. This is particularly useful for objects with simple scopes (\u201cstop when I stop\u201d) or very custom state that requires custom handling.</p> <p>Note that Exceptions can be thrown in this, and will be routed through <code>onError()</code>. If the thrown exception is an instance of <code>OutsideScopeException</code>, it will be routed through any <code>OutsideScopeHandler</code>s (more below) first, and sent through <code>onError()</code> if not handled.</p>"},{"location":"#autodisposeplugins","title":"AutoDisposePlugins","text":"<p>Modeled after RxJava\u2019s plugins, this allows you to customize the behavior of AutoDispose.</p>"},{"location":"#outsidescopehandler","title":"OutsideScopeHandler","text":"<p>When a scope is bound to outside of its allowable boundary, <code>AutoDispose</code> will send an error event with an  <code>OutsideScopeException</code> to downstream consumers. If you want to customize this behavior, you can use  <code>AutoDisposePlugins#setOutsideScopeHandler</code> to intercept these exceptions and rethrow something  else or nothing at all.</p> <p>Example <pre><code>AutoDisposePlugins.setOutsideScopeHandler(t -&gt; {\n// Swallow the exception, or rethrow it, or throw your own!\n})\n</code></pre></p> <p>A good use case of this is, say, just silently disposing/logging observers outside of scope exceptions in production but crashing on debug.</p> <p>The supported mechanism to throw this is in <code>ScopeProvider#requestScope()</code> implementations.</p>"},{"location":"#fillinoutsidescopeexceptionstacktraces","title":"FillInOutsideScopeExceptionStacktraces","text":"<p>If you have your own handling of exceptions in scope boundary events, you can optionally set <code>AutoDisposePlugins#setFillInOutsideScopeExceptionStacktraces</code> to <code>false</code>. This will result in AutoDispose <code>not</code> filling in stacktraces for exceptions, for a potential minor performance boost.</p>"},{"location":"#autodisposeandroidplugins","title":"AutoDisposeAndroidPlugins","text":"<p>Similar to <code>AutoDisposePlugins</code>, this allows you to customize the behavior of AutoDispose in Android environments.</p>"},{"location":"#mainthreadchecker","title":"MainThreadChecker","text":"<p>This plugin allows for supplying a custom <code>BooleanSupplier</code> that can customize how main thread checks work. The conventional use case of this is Android JUnit tests, where the <code>Looper</code> class is not stubbed in the mock android.jar and fails explosively when touched.</p> <p>Another potential use of this at runtime to customize checks for more fine-grained main thread checks behavior.</p> <p>Example <pre><code>AutoDisposeAndroidPlugins.setOnCheckMainThread(() -&gt; {\nreturn true; // Use whatever heuristics you prefer.\n})\n</code></pre></p>"},{"location":"#behavior","title":"Behavior","text":"<p>Under the hood, AutoDispose decorates RxJava\u2019s real observer with a custom AutoDisposing observer. This custom observer leverages the scope to create a disposable, auto-disposing observer that acts as a lambda observer (pass-through) unless the underlying scope <code>CompletableSource</code> emits <code>onComplete</code>. Both scope emission and upstream termination result in immediate disposable of both the underlying scope subscription and upstream disposable.</p> <p>These custom <code>AutoDisposing</code> observers are considered public read-only API, and can be found under the <code>observers</code> package. They also support retrieval of the underlying observer via <code>delegateObserver()</code> methods. Read-only API means that the public signatures will follow semantic versioning, but we may add new methods in the future (which would break compilation if you make custom implementations!).</p> <p>To read this information, you can use RxJava\u2019s <code>onSubscribe</code> hooks in <code>RxJavaPlugins</code> to watch for instances of these observers.</p>"},{"location":"#supportextensions","title":"Support/Extensions","text":"<p><code>Flowable</code>, <code>ParallelFlowable</code>, <code>Observable</code>, <code>Maybe</code>, <code>Single</code>, and <code>Completable</code> are all supported. Implementation is solely based on their <code>Observer</code> types, so conceivably any type that uses those for subscription should work.</p>"},{"location":"#extensions","title":"Extensions","text":"<p>There are also a number of extension artifacts available, detailed below.</p>"},{"location":"#lifecyclescopeprovider","title":"LifecycleScopeProvider","text":"<pre><code>public interface LifecycleScopeProvider&lt;E&gt; extends ScopeProvider {\nObservable&lt;E&gt; lifecycle();\n\nFunction&lt;E, E&gt; correspondingEvents();\n\nE peekLifecycle();\n\n// Inherited from ScopeProvider\nCompletableSource requestScope();\n}\n</code></pre> <p>A common use case for this is objects that have implicit lifecycles, such as Android\u2019s <code>Activity</code>, <code>Fragment</code>, and <code>View</code> classes. Internally at subscription-time, <code>AutoDispose</code> will resolve a <code>CompletableSource</code> representation of the target <code>end</code> event in the lifecycle, and exposes an API to dictate what corresponding events are for the current lifecycle state (e.g. <code>ATTACH</code> -&gt; <code>DETACH</code>). This also allows you to enforce lifecycle boundary requirements, and by default will error if the lifecycle has either not started yet or has already ended.</p> <p><code>LifecycleScopeProvider</code> is a special case targeted at binding to things with lifecycles. Its API is as follows:   - <code>lifecycle()</code> - returns an <code>Observable</code> of lifecycle events. This should be backed by a <code>BehaviorSubject</code>   or something similar (<code>BehaviorRelay</code>, etc).   - <code>correspondingEvents()</code> - a mapping of events to corresponding ones, i.e. Attach -&gt; Detach.   - <code>peekLifecycle()</code> - returns the current lifecycle state of the object.</p> <p>In <code>requestScope()</code>, the implementation expects to these pieces to construct a <code>CompletableSource</code> representation of the proper end scope, while also doing precondition checks for lifecycle boundaries. If a lifecycle has not started, it will send you to <code>onError</code> with a <code>LifecycleNotStartedException</code>. If the lifecycle as ended, it is recommended to throw a <code>LifecycleEndedException</code> in your <code>correspondingEvents()</code> mapping, but it is up to the user.</p> <p>To simplify implementations, there\u2019s an included <code>LifecycleScopes</code> utility class with factories for generating <code>CompletableSource</code> representations from <code>LifecycleScopeProvider</code> instances.</p> <p><code>autodispose-lifecycle</code> contains the core <code>LifecycleScopeProvider</code> and <code>LifecycleScopes</code> APIs as well as a convenience test helper.</p>"},{"location":"#android","title":"Android","text":"<p>There are three artifacts with extra support for Android: * <code>autodispose-android</code> has a <code>ViewScopeProvider</code> for use with Android <code>View</code> classes. * <code>autodispose-androidx-lifecycle</code> has a <code>AndroidLifecycleScopeProvider</code> for use with <code>LifecycleOwner</code> and <code>Lifecycle</code> implementations.</p> <p>Note that the project is compiled against Java 8. If you need support for lower Java versions, you should use D8 (Android Gradle Plugin 3.2+) or desugar as needed (depending on the build system).</p>"},{"location":"#kotlin","title":"Kotlin","text":"<p>Kotlin extensions are bundled with almost every artifact.</p> <p>For coroutines - there is an <code>autodispose-coroutines-interop</code> artifact for interoperability between <code>CoroutineScope</code> and <code>ScopeProvider</code>/<code>Completable</code> types.</p>"},{"location":"#rxlifecycle","title":"RxLifecycle","text":"<p>As of 0.4.0 there is an RxLifecycle interop module under <code>autodispose-rxlifecycle</code>. This is for interop with RxLifecycle\u2018s <code>LifecycleProvider</code> interfaces.</p>"},{"location":"#philosophy","title":"Philosophy","text":"<p>Each factory returns a subscribe proxies upon application that just proxy to real subscribe calls under the hood to \u201cAutoDisposing\u201d implementations of the types. These types decorate the actual observer at subscribe-time to achieve autodispose behavior. The types are not exposed directly because autodisposing has ordering requirements; specifically, it has to be done at the end of a chain to properly wrap all the upstream behavior. Lint could catch this too, but we have seen no use cases for disposing upstream (which can cause a lot of unexpected behavior). Thus, we optimize for the common case, and the API is designed to prevent ordering issues while still being a drop-in one-liner.</p>"},{"location":"#motivations","title":"Motivations","text":"<p>Lifecycle management with RxJava and Android is nothing new, so why yet another tool?</p> <p>Two common patterns for binding execution in RxJava that we used prior to this were as follows:</p> <ul> <li><code>CompositeSubscription</code> field that all subscriptions had to be manually added to.</li> <li><code>RxLifecycle</code>, which works via <code>compose()</code> to resolve the lifecycle end event and ultimately transform the given observable to <code>takeUntil()</code> that event is emitted.</li> </ul> <p>Both implementations are elegant and work well, but came with caveats that we sought to revisit and solve in AutoDispose.</p> <p><code>CompositeSubscription</code> requires manual capture of the return value of <code>subscribe</code> calls, and gets tedious to reason about with regards to binding subscription until different events.</p> <p><code>RxLifecycle</code> solves the caveats of <code>CompositeSubscription</code> use by working in a dead-simple API and handling resolution of corresponding events. It works great for <code>Observable</code> types, but due to the nature of how <code>takeUntil()</code> works, we found that <code>Single</code> and <code>Completable</code> usage was risky to use (particularly in a  large team with varying levels of RxJava experience) considering lifecycle interruption would result in a downstream <code>CancellationException</code> every time. It\u2019s the contract of those types, but induced a lot of ceremony for what would otherwise likely be our most commonly used type (<code>Single</code>). Even with <code>Observable</code>, we were still burned occasionally by the completion event still coming through to an unsuspecting engineer. Another caveat we often ran into (and later aggressively linted against) was that the <code>compose()</code> call had ordering implications, and needed to be as close to the <code>subscribe()</code> call as possible to properly wrap upstream. If binding to views, there were also threading requirements on the observable chain in order to work properly.</p> <p>At the end of the day, we wanted true disposal/unsubscription-based behavior, but with RxLifecycle-esque semantics around scope resolution. RxJava 2\u2019s <code>Observer</code> interfaces provide the perfect mechanism for  this via their <code>onSubscribe()</code> callbacks. The result is de-risked <code>Single</code>/<code>Completable</code> usage, no ordering  concerns, no threading concerns (fingers crossed), and true disposal with no further events of any kind  upon scope end. We\u2019re quite happy with it, and hope the community finds it useful as well.</p> <p>Special thanks go to Dan Lew (creator of RxLifecycle), who helped pioneer this area for RxJava  in android and humored many of the discussions around lifecycle handling over the past couple years  that we\u2019ve learned from. Much of the internal scope resolution mechanics of <code>AutoDispose</code> are  inspired by RxLifecycle.</p>"},{"location":"#rxjava-versions-support","title":"RxJava versions support","text":"RxJava version AutoDispose version RxJava 3 AutoDispose 2.x RxJava 2 AutoDispose 1.x RxJava 1 Unsupported <ul> <li> <p>We do not plan to try to backport this to RxJava 1. This pattern is sort of possible in RxJava 1, but only on <code>Subscriber</code> (via <code>onStart()</code>) and <code>CompletableObserver</code> (which matches the API of RxJava 2+)</p> </li> <li> <p>2.x versions of AutoDispose are built for RxJava 3.</p> </li> </ul>"},{"location":"#static-analysis","title":"Static analysis","text":""},{"location":"#error-prone","title":"Error Prone","text":"<p>There is an optional error-prone checker you can use to enforce use of AutoDispose. Integration steps and more details can be found on the website</p>"},{"location":"#lint-check","title":"Lint Check","text":"<p>AutoDispose ships with a lint check that detects missing AutoDispose scope within defined scoped elements. Integration steps and more details can be found on the website</p>"},{"location":"#download","title":"Download","text":"<p>Java:</p> <p></p> <pre><code>implementation 'com.uber.autodispose2:autodispose:x.y.z'\n</code></pre> <p>LifecycleScopeProvider:</p> <p> <pre><code>implementation 'com.uber.autodispose2:autodispose-lifecycle:x.y.z'\n</code></pre></p> <p>Android extensions:</p> <p> <pre><code>implementation 'com.uber.autodispose2:autodispose-android:x.y.z'\n</code></pre></p> <p>Android Architecture Components extensions:</p> <p> <pre><code>// AutoDispose 1.x\nimplementation 'com.uber.autodispose:autodispose-android-archcomponents:x.y.z'\n\n// AutoDispose 2.x\nimplementation 'com.uber.autodispose2:autodispose-androidx-lifecycle:x.y.z'\n</code></pre></p> <p>Androidx-Lifecycle Test extensions:</p> <p> <pre><code>// AutoDispose 1.x\nimplementation 'com.uber.autodispose:autodispose-android-archcomponents-test:x.y.z'\n\n// AutoDispose 2.x\nimplementation 'com.uber.autodispose2:autodispose-androidx-lifecycle-test:x.y.z'\n</code></pre></p> <p>RxLifecycle interop (AutoDispose 1.x/RxJava 2.x only):</p> <p><code>autodispose-rxlifecycle</code> <pre><code>implementation 'com.uber.autodispose:autodispose-rxlifecycle:x.y.z'\n</code></pre></p> <p><code>autodispose-rxlifecycle3</code> <pre><code>implementation 'com.uber.autodispose:autodispose-rxlifecycle3:x.y.z'\n</code></pre></p> <p>Javadocs and KDocs for the most recent release can be found here: https://uber.github.io/AutoDispose/2.x/autodispose/</p> <p>Snapshots of the development version are available in Sonatype\u2019s snapshots repository.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#version-220","title":"Version 2.2.0","text":"<p>2023-07-23</p> <ul> <li>Fix: Dispose the handle returned by <code>Job.invokeOnCompletion</code> when Rx subscription is disposed.</li> <li>Fix: The <code>withScope()</code> lint now correctly handles different named arguments order.</li> <li>Update AndroidX Lifecycle to <code>2.6.1</code>.</li> <li>Update Kotlin to <code>1.9.0</code>.</li> <li>Update RxJava to <code>3.1.6</code>.</li> <li>Update RxAndroid to <code>3.0.2</code>.</li> <li>Update lint to <code>8.0.2</code>/<code>31.0.2</code>.</li> <li>Update error-prone to <code>2.20.0</code>.</li> <li>Update dokka + fresh coat of paint on API docs on the project site.</li> </ul>"},{"location":"changelog/#version-211","title":"Version 2.1.1","text":"<p>2021-09-07</p> <ul> <li>Fix: <code>SingleSubscribeProxy#subscribe(BiConsumer)</code> now propagates the correct nullability. Previously, both parameters were implicitly <code>@NonNull</code>. Now they are correctly annotated as <code>@Nullable</code>.</li> <li>Update Kotlin to <code>1.5.30</code>.</li> <li>Update Error Prone Annotations to <code>2.9.0</code>.</li> <li>Switch to Error Prone\u2019s <code>@DoNotMock</code> annotation.</li> </ul>"},{"location":"changelog/#version-210","title":"Version 2.1.0","text":"<p>2021-08-09</p> <ul> <li>Add <code>@NonNull</code> or <code>: Any</code> to type arguments where appropriate for better nullability contracts in generics.</li> <li>Fix lint using \u201cmainProject\u201d instead of \u201cproject\u201d, meaning this now supports AGP 7.0.0.</li> <li>Add lint support for RxKotlin extensions or your own extensions</li> <li>See the docs for configuration details!</li> <li>Lint is now published as a dedicated artifact for use in pure JVM projects.   <pre><code>plugins {\nid \"org.jetbrains.kotlin.jvm\"\nid \"com.android.lint\"\n}\n\ndependencies {\nlintChecks \"com.uber.autodispose2:autodispose-lint:&lt;version&gt;\"\n}\n</code></pre></li> <li>Deprecate <code>TestLifecycleOwner</code> artifact + its extensions in favor of the first party <code>androidx.lifecycle.testing.TestLifecycleOwner</code> option.</li> <li>See an example migration in this PR.</li> <li>Update to RxJava <code>3.1.0</code></li> <li>Update to Kotlin <code>1.5.21</code></li> <li>Update to androidx.lifecycle <code>2.3.1</code></li> <li>Update to Error-Prone <code>2.8.1</code></li> <li>Update to kotlinx.coroutines <code>1.5.1</code></li> <li>Update to lint <code>30.0.0</code></li> </ul> <p>Note that we are no longer releasing AutoDispose 1.x versions as RxJava 2 reached End of Life in February 2021.</p> <p>Thanks to @Rajin9601, @ianhanniballake, @rafaeltoledo, and @msridhar for contributing to this release!</p>"},{"location":"changelog/#version-200","title":"Version 2.0.0","text":"<p>2020-02-23</p> <p>AutoDispose 2 is built against RxJava 3 and is binary-compatible with AutoDispose 1.x and RxJava 2.x. As such - it has a different package name and maven group ID.</p>"},{"location":"changelog/#packaging","title":"Packaging","text":"Maven Group ID Package Name 1.x <code>com.uber.autodispose</code> <code>com.uber.autodispose</code> 2.x <code>com.uber.autodispose2</code> <code>autodispose2</code> <p>For any sub-packages, the above mapping should be used for those package prefix replacements as well.</p>"},{"location":"changelog/#changes","title":"Changes","text":"<ul> <li>All deprecated APIs in 1.x have been removed. This consisted exclusively of deprecated Kotlin <code>autoDisposable</code> extension functions that were deprecated in 1.4.0.</li> <li>The <code>autodispose-android-archcomponents*</code> artifacts have been renamed to to <code>autodispose-androidx-lifecycle*</code> to match the <code>androidx-lifecycle</code> library they correspond to.</li> <li>The lint and error prone checks have also been updated.</li> <li>At the time of writing, there is no RxLifecycle with RxJava 3 support yet, and as such there is no AutoDispose 2.x interop artifact for RxLifecycle. We can add this back if there\u2019s a new RxLifecycle release with RxJava 3.x support.</li> </ul> <p>You can find migration steps on the project site at https://uber.github.io/AutoDispose/migrating-1x-2x/.</p>"},{"location":"changelog/#version-200-rc2","title":"Version 2.0.0-RC2","text":"<p>2019-12-02</p> <p>RC2 has no additional changes from RC1 but does not upload RCs for Android artifacts since RxAndroid does not have a RC yet.</p>"},{"location":"changelog/#version-200-rc1","title":"Version 2.0.0-RC1","text":"<p>2019-12-01</p> <p>This is the first release candidate for AutoDispose 2.0</p> <p>AutoDispose 2 is built against RxJava 3 and is binary-compatible with AutoDispose 1.x and RxJava 2.x. As such - it has a different package name and maven group ID.</p>"},{"location":"changelog/#android-not-supported-yet","title":"Android not supported yet","text":"<p>Due to there being no RxAndroid 3.x release candidate, we cannot release RCs of the Android artifacts yet. They are available as snapshots though.</p>"},{"location":"changelog/#packaging_1","title":"Packaging","text":"Maven Group ID Package Name 1.x <code>com.uber.autodispose</code> <code>com.uber.autodispose</code> 2.x <code>com.uber.autodispose2</code> <code>autodispose2</code> <p>For any sub-packages, the above mapping should be used for those package prefix replacements as well.</p>"},{"location":"changelog/#changes_1","title":"Changes","text":"<ul> <li>All deprecated APIs in 1.x have been removed. This consisted exclusively of deprecated Kotlin <code>autoDisposable</code> extension functions that were deprecated in 1.4.0.</li> <li>The <code>autodispose-android-archcomponents*</code> artifacts have been renamed to to <code>autodispose-androidx-lifecycle*</code> to match the <code>androidx-lifecycle</code> library they correspond to.</li> <li>The lint and error prone checks have also been updated. We may look at consolidating these before 2.0 final is released if the community wants.</li> <li>At the time of writing, there is no RxLifecycle with RxJava 3 support yet, and as such there is no AutoDispose 2.x interop artifact for RxLifecycle. We can add this back if there\u2019s a new RxLifecycle release with RxJava 3.x support.</li> </ul> <p>We\u2019ll be maintaining a running document of migration steps on the project site at https://uber.github.io/AutoDispose/migrating-1x-2x/.</p>"},{"location":"changelog/#version-140","title":"Version 1.4.0","text":"<p>2019-09-18</p>"},{"location":"changelog/#kotlin-coroutinescope-interop-374","title":"Kotlin <code>CoroutineScope</code> interop #374","text":"<p>Interop functions for <code>CoroutineScope</code> to <code>ScopeProvider</code>/<code>Completable</code> (and vice versa) are now available in a new <code>autodispose-coroutines-interop</code> artifact. This is not intended to allow AutoDispose\u2019s scoping machinery be a competitor for it, but rather just a tool for interop-ing codebases that use both or aid in migrations.</p>"},{"location":"changelog/#kotlin-api-naming-improvements-372-377","title":"Kotlin API naming improvements #372 #377","text":"<p>To better differentiate between the <code>AutoDispose</code> classes\u2019s <code>autoDisposable()</code> methods (which return Rx converter types), the Kotlin <code>autoDisposable()</code> extensions have been deprecated in favor of a more idiomatic <code>autoDispose()</code> verb form name. The old extensions have been annotated with <code>@Deprecated</code> and replacements, so this should be an easy one time migration.</p> <pre><code>myObservable\n.autoDispose(scope)\n.subscribe()\n</code></pre>"},{"location":"changelog/#fused-proxy-types-376","title":"Fused proxy types #376","text":"<p>AutoDispose\u2019s analogous Rx types (<code>AutoDisposeObservable</code>, etc) have been updated to implement their <code>*SubscribeProxy</code> interfaces directly. The current behavior of subscribe proxies is best thought of as similar to <code>hide()</code>. Subscribe proxies have always wrapped the AutoDispose\u2019s analogous Rx types to prevent upcasting. If your team are good citizens though, you can now disable proxy hiding via <code>AutoDisposePlugins</code> to save that extra allocation.</p>"},{"location":"changelog/#new-withscope-api-375-378","title":"New <code>withScope()</code> API #375 #378","text":"<p>There is a new Kotlin <code>withScope()</code> API that accepts a scope and a body to execute in. This body is a function-with-receiver tied to a new <code>AutoDisposeContext</code> interface, which has no-arg <code>autoDispose()</code> functions in it. This allows for calling <code>autoDispose()</code> within the context of the body and allow the enclosing context manage wiring the applied scope to it.</p> <pre><code>@Test\nfun example() = withScope(scope) {\nObservable.just(\"Hello withScope()!\")\n.autoDispose()\n.subscribe()\n}\n</code></pre>"},{"location":"changelog/#dependency-updates","title":"Dependency updates","text":"<pre><code>Kotlin: 1.3.50\nLint tools: 26.5.0\n</code></pre>"},{"location":"changelog/#version-130","title":"Version 1.3.0","text":"<p>2019-05-15</p>"},{"location":"changelog/#unified-kotlin-extensions","title":"Unified Kotlin extensions","text":"<p>Starting with 1.3.0, all the <code>-ktx</code> artifacts and their kotlin extensions have been merged into the main artifacts they extended. This means that extensions in an artifact like <code>autodispose-android-ktx</code> are now available directly in the corresponding <code>autodispose-android</code>.</p> <p>This is a binary-compatible change because the extensions file name has changed while the extensions themselves have remained in the same package. So in essence, <code>import com.uber.autodispose.autoDisposable</code> still works as-is. Just remove the ktx artifact dependencies and everything will still link as-is!</p> <p>The Kotlin standard library has been added as an <code>compileOnly</code> dependency of artifacts containing Kotlin bindings. This is to avoid imposing the dependency for non-Kotlin users, but the expectation is for Kotlin users to bring their own standard library dependency to fulfill this if used. Considering the standard library is an ubiquitous dependency for Kotlin projects, we don\u2019t expect this to be an issue and drew inspiration for this design from Retrofit.</p> <p>Proguard/R8 <code>.pro</code> files in the unified artifacts have been updated to not warn on these <code>KotlinExtensions</code> files as they can be safely stripped in builds if unused.</p> <p>NOTE: One important thing this revealed was that the ktx artifacts were built with jdk target 1.6, while depending on Java artifacts that were built against JDK 8. Now that they are unified, this means that the Kotlin extensions require targeting JDK 1.8 as well (configurable via compiler arg <code>-jvm-target=1.8</code>).</p> <p>PRs: #339 #341 #346</p>"},{"location":"changelog/#more-kotlin-extensions","title":"More Kotlin extensions!","text":"<p>Initially, we only provided minimal Kotlin extensions to support scopes on extra types like Android\u2019s <code>LifecycleOwner</code>, <code>View</code>, etc. This resulted in a bit of ceremony for these APIs to be used though, such as:</p> <pre><code>Observable.just(1)\n.autoDisposable(AndroidLifecycleScopeProvider.from(this))\n.subscribe()\n</code></pre> <p>To simplify this, we\u2019ve added the following top-level extension functions for the following: * <code>autodispose-android</code> - <code>View</code> * <code>autodispose-archcomponents</code> - <code>LifecycleOwner</code> * <code>autodispose-rxlifecycle</code> - <code>LifecycleProvider</code> * <code>autodispose-rxlifecycle3</code> - <code>LifecycleProvider</code></p> <p>So now, the above snippet could just be:</p> <pre><code>Observable.just(1)\n.autoDisposable(this)\n.subscribe()\n</code></pre> <p>PRs: #348 #353</p>"},{"location":"changelog/#removed-deprecated-lifecycle-artifacts","title":"Removed deprecated lifecycle artifacts","text":"<p>Following their deprecating in 1.1.0, the <code>autodispose-lifecycle-jdk8</code> and <code>autodispose-lifecycle-ktx</code> artifacts are no longer published. Please move to just using <code>LifecycleScopeProvider</code> directly.</p>"},{"location":"changelog/#misc","title":"Misc","text":"<p>Dependency updates</p> <pre><code>Kotlin: 1.3.31\nAndroidX Annotations: 1.0.2\nRxJava: 2.2.8\nRxAndroid: 2.1.1\n</code></pre> <p>Artifact changes</p> Original Merged into (if applicable) autodispose-ktx autodispose autodispose-android-ktx autodispose-android autodispose-android-archcomponents-ktx autodispose-android-archcomponents autodispose-android-archcomponents-test-ktx autodispose-android-archcomponents-test autodispose-lifecycle-ktx N/A autodispose-lifecycle-jdk8 N/A <p>Note: This does not mean the existing versions were deleted or removed in any way, just that we will not publish 1.3.0 or later versions of them.</p>"},{"location":"changelog/#version-120","title":"Version 1.2.0","text":"<p>2019-04-03</p> <ul> <li>Fixes a bug which allows Lint to refer to the app level <code>gradle.properties</code> file for configuration support. #335</li> <li>New <code>autodispose-rxlifeycle3</code> artifact for interop with RxLifecycle3. #319</li> <li>Various dependency updates <pre><code>Lint: 26.3.2\nKotlin 1.3.21\n</code></pre></li> </ul> <p>All PRs: #319, #320, #322, #326, #327 #328, #329, #330, #334, #335, #336</p>"},{"location":"changelog/#version-110","title":"Version 1.1.0","text":"<p>2018-12-13</p>"},{"location":"changelog/#static-analysis","title":"Static Analysis","text":"<p>This is a big static analysis release. AutoDispose now ships with two static analysis artifacts: <code>autodispose-lint</code> for Android Lint and <code>autodispose-error-prone</code> for Error-Prone.</p> <p>Both of these checks operate by detecting uses of standard RxJava <code>subscribe</code>/<code>subscribeWith</code> calls in the context of something that has scope (such as a <code>ScopeProvider</code>). If they\u2019re detected, the lint/checker will mark them as missing <code>Disposable</code> handling and suggest either using AutoDispose or (if <code>lenient</code> mode enabled) manually handle the returned <code>Disposable</code>.</p> <p>Both checks have configuration support:</p> <ul> <li><code>TypesWithScope</code> - a comma-separated list of custom types with scope. By default, this is additive to default scopes.</li> <li><code>OverrideScopes</code> - a boolean flag indicating if <code>TypesWithScope</code> should override the built-in scopes. <code>false</code> by default.</li> <li><code>Lenient</code> - a boolean flag to enable a lenient mode that tells the linter to ignore cases where the returned <code>Disposable</code> is captured (aka \u201cI know what I\u2019m doing\u201d mode). <code>false</code> by default.</li> </ul> <p>Both checkers should have feature parity. They have different advantages: the Error-Prone check runs at compile-time, and lint will show up in the IDE and run on Kotlin code. You should use whichever one fits your stack best.</p> <p>Full integration instructions can be found on their respective wikis:</p> <ul> <li>https://github.com/uber/AutoDispose/wiki/Lint-Check</li> <li>https://github.com/uber/AutoDispose/wiki/Error-Prone</li> </ul> <p>Prior to this release, the Error Prone checker was missing a required service file to run, so the new artifact is different than the previous one (but not conflicting since the old one never worked!).</p> <p>This was a major project and contribution from a new maintainer to the project! @shaishavgandhi05</p> <p>All PRs: #316, #315, #313, #312, #310, #307, #308, #306, #299, #303, #301, #300, #282, #291, #292</p>"},{"location":"changelog/#defaultlifecyclescopeprovider-and-kotlinlifecyclescopeprovider-deprecation-275","title":"DefaultLifecycleScopeProvider and KotlinLifecycleScopeProvider Deprecation (#275)","text":"<p><code>DefaultLifecycleScopeProvider</code> and <code>KotlinLifecycleScopeProvider</code> are now deprecated, and their default <code>requestScope()</code> behavior now elevated into the based <code>LifecycleScopeProvider</code> class. This is implemented as a Java 8 <code>default</code> interface method.</p>"},{"location":"changelog/#misc_1","title":"Misc","text":"<ul> <li>Non-android <code>-ktx</code> artifacts now use <code>implementation</code>/<code>api</code> dependencies (#277)</li> <li><code>automatic-module-name</code> is added to relevant JDK modules (#281)</li> <li>Updated doc on <code>RxLifecycleInterop</code> (#280)</li> <li>Kotlin is updated to 1.3.11 #274, #309</li> </ul> <p>Thanks to the following external contributors for this release: @MarkyC</p>"},{"location":"changelog/#version-100","title":"Version 1.0.0","text":"<p>2018-10-10</p> <ul> <li>Stable release!</li> <li>This is identical in functionality to 1.0.0-RC3 but completely migrated to the new AndroidX artifacts. From this point forward for Android projects, you must be on AndroidX artifacts. You can use 1.0.0-RC3 to ease migration if need be.</li> </ul>"},{"location":"changelog/#version-100-rc3","title":"Version 1.0.0-RC3","text":"<p>2018-10-10</p> <ul> <li>The project now targets Java 8 bytecode, with the expectation that projects are either on Java 8 or (if on Android) use D8 via Android Gradle Plugin 3.2.0. (#257)</li> <li>More sample recipes for Android ViewModels and Fragments (#254) (#260)</li> <li>Various dependency updates</li> </ul> <pre><code>Support library 28.0.0\nArchitecture Components (runtime) 1.1.1\nKotlin 1.2.71\nRxJava 2.2.2\nRxAndroid 2.1.0\n</code></pre> <p>Thanks to the following contributors for this release: @shaishavgandhi05</p>"},{"location":"changelog/#version-100-rc2","title":"Version 1.0.0-RC2","text":"<p>2018-8-14</p> <p>Small followup update to RC1</p> <ul> <li><code>subscribe(Observer)</code> methods in <code>SubscribeProxy</code> interfaces now accept wildcards for the observer type, matching their RxJava counterparts (#244)</li> <li>Example: <code>subscribe(Observer&lt;T&gt; observer)</code> -&gt; <code>subscribe(Observer&lt;? super T&gt; observer)</code></li> <li>Kotlin artifacts now include <code>Module.md</code> files in dokka documentation (#238)</li> <li>Android lifecycle Kotlin <code>scope()</code> extensions now return <code>ScopeProvider</code> instead of <code>LifecycleScopeProvider</code> (#239)</li> </ul> <p>Thanks to the following contributors for this release: @shaishavgandhi05</p>"},{"location":"changelog/#version-100-rc1","title":"Version 1.0.0-RC1","text":"<p>2018-8-2</p> <p>This is the first release candidate of AutoDispose 1.0!</p>"},{"location":"changelog/#completable-replaces-maybe-as-the-source-of-truth-for-scoping-234","title":"<code>Completable</code> replaces <code>Maybe</code> as the source of truth for scoping (#234)","text":"<p>Note: we say <code>Completable</code> for semantic convenience, but in code it\u2019s almost always referred to via <code>CompletableSource</code> for flexibility</p> <p>This is a significant API change, but a good one we want to clean up before releasing 1.0. Since its inception, AutoDispose has always coerced scopes into a <code>Maybe</code> representation. Now, scopes are coerced to a <code>CompletableSource</code>.</p> <p><code>Maybe</code> seemed like the right idea for something that \u201cmay or may not emit\u201d, but in our case we actually don\u2019t care about the difference between onSuccess or onComplete. We did have a notion of \u201cUNBOUND\u201d, but that doesn\u2019t offer anything other than a severed lifecycle scope disposal in an atomic reference (no other cleanups would happen for gc, etc). This brings us to a <code>Single</code>. The thing is though, we don\u2019t care about the object/element type. A <code>Single</code> where the type doesn\u2019t matter is semantically a <code>Completable</code>, and thus this change.</p> <p>Note that semantics are slightly different for anyone that sourced scope via emissions from an <code>Observable</code>, <code>Maybe</code>, <code>Completable</code>, or <code>Flowable</code>, where before a completion event would not trigger disposal. Now it would. In the lifecycle artifact, completion of the lifecycle or emission of the target event (via <code>takeUntil()</code>) will signal disposal.</p> <p>If there\u2019s a strong desire for it, we could look at adding top-level <code>autoDisposable</code> overrides that accept other RxJava types (and coerce them to <code>Completable</code>).</p>"},{"location":"changelog/#lifecycle-components-are-now-a-separate-artifact-228","title":"Lifecycle components are now a separate artifact (#228)","text":"<p><code>LifecycleScopeProvider</code> is now in a separate artifact under <code>autodispose-lifecycle</code>, and now just extends <code>ScopeProvider</code>. This is sort of something we always wanted to do, as the recommended solution for AutoDispose is namely to use <code>ScopeProvider</code> and standard RxJava types. <code>LifecycleScopeProvider</code> supports corresponding-events-type lifecycles for use with lifecycle components like Android, but we mostly see this as a mechanism for boundary checks. Dan Lew excellently discusses this subject in his \u201cWhy Not RxLifecycle?\u201d blog post.</p> <p>This does come with the caveat that one must implement <code>requestScope()</code> in implementations now. To smoothen this usage, a <code>autodispose-lifecycle-jdk8</code> artifact exists with a <code>DefaultLifecycleScopeProvider</code> that has a <code>default</code> implementation of this on Java 8+ that matches the existing behavior. A similar default behavior was added for the <code>autodispose-lifecycle-ktx</code> artifact. These behaviors can be further tuned via factory helpers in <code>LifecycleScopes</code>.</p> <p>Other notable changes in this: * <code>OutsideLifecycleException</code> has been renamed to <code>OutsideScopeException</code> and kept in the core artifact. Boundary checks can be done and respected in <code>ScopeProvider</code> implementations, and corresponding <code>AutoDisposePlugins</code> for this have been renamed accordingly. * <code>correspondingEvents()</code> now returns a <code>CorrespondingEventsFunction</code>, which is a narrower subtype of <code>Function</code> that only needs one generic and only allows for throwing `OutsideScopeException.</p>"},{"location":"changelog/#misc_2","title":"Misc","text":"<ul> <li>All deprecated APIs have been removed.</li> <li>Kotlin Artifacts have been renamed to be <code>{name}-ktx</code> instead of <code>{name}-kotlin</code> to match other library conventions.</li> <li>Kotlin artifacts with <code>.ktx</code> or <code>.kotlin</code> package name entries have had them removed to match convention with other ktx-style artifacts.</li> <li>i.e. Instead of <code>com.uber.autodispose.kotlin</code>, it would just be <code>com.uber.autodispose</code>.</li> <li><code>ViewScopeProvider</code> now uses a custom <code>MainThreadDisposable</code> that respects any main thread checks set via <code>AutoDisposeAndroidPlugins</code>. (#232)</li> <li>Jetbrains annotations have been removed in favor of just using RxJava\u2019s <code>@Nullable</code> annotation directly. Saves some proguard rules and dependencies, and also makes annotation usage consistent.</li> <li>The following dependencies have been updated:</li> <li>RxJava 2.2.0 (<code>as()</code> and <code>ParallelFlowable</code> are now stable APIs)</li> <li>Kotlin 1.2.60</li> <li>Build against Android SDK 28</li> <li>Support library 27.1.1</li> <li>RxLifecycle 2.2.2</li> <li>RxAndroid 2.0.2</li> <li>The sample app has had some wonderful community contributions</li> <li>LeakCanary integration</li> <li>Architecture components sample, including <code>ViewModel</code> and using a repository pattern</li> <li>General structure cleanup</li> </ul> <p>This is an RC1. We won\u2019t release 1.0 final until the AndroidX artifacts are stable to save ourselves from having to release a 2.0 immediately after this. These are a lot of breaking changes, so please let us know if you see any issues.</p> <p>Thanks to the following contributors for this release: @shaishavgandhi05 and @remcomokveld</p>"},{"location":"changelog/#version-080","title":"Version 0.8.0","text":"<p>2018-5-7</p>"},{"location":"changelog/#deprecated-scoper-apis-now-use-the-converter-api-under-the-hood-188","title":"Deprecated Scoper APIs now use the converter API under the hood (#188)","text":"<p>Up to this point, the new <code>as()</code>-based converter APIs just delegated to the existing deprecated <code>to()</code> APIs. In this release, they have been flipped, such that the <code>to()</code> APIs now just point to the <code>as()</code>-based APIs. This should be no visible user change, but please let us know if you see any issues.</p>"},{"location":"changelog/#viewscopeprovider-now-implements-scopeprovider-instead-of-lifecyclescopeprovider-196","title":"ViewScopeProvider now implements ScopeProvider instead of LifecycleScopeProvider (#196)","text":"<p>We believe this makes more sense, as there\u2019s no beginning boundary check for Views that we can check and the general attach state is quite simple. This also avoids leaking an unnecessary internal API.</p>"},{"location":"changelog/#defer-to-comparable-checks-if-lifecyclescopeprovider-types-implement-it-196","title":"Defer to <code>Comparable</code> checks if <code>LifecycleScopeProvider</code> types implement it (#196)","text":"<p>For better flexibility, if a type for <code>LifecycleScopeProvider</code> implements <code>Comparable</code>, we will defer to it rather than <code>equals()</code>. This allows for consumers to better convey event ordering to the scope provider, and allow AutoDispose to catch events after a target event as a fallback. This covers cases where the targeted \u201cend\u201d event is missed but a later event comes through, allowing AutoDispose to dispose anyway. Note that this may result in a behavior change if your lifecycle types implemented <code>Comparable</code> before.</p>"},{"location":"changelog/#removed-error-prone-annotations-208","title":"Removed Error-Prone annotations (#208)","text":"<p>As of Error-Prone 2.3.1, <code>@DoNotMock</code> was removed. We\u2019ve switched to an internal copy of this annotation for documentation purposes and for any external checkers to still check this usage on their own (by name).</p>"},{"location":"changelog/#switch-from-jsr305-to-jetbrains-annotations-for-nullability-208","title":"Switch from JSR305 to Jetbrains annotations for nullability (#208)","text":"<p>To be compatible with the Java 9 module system, we\u2019ve switched away from the JSR 305 annotations/javax-extras on packages and now use the Jetbrains annotations for nullability instead. We still abide by a nonnull-by-default implementation, and only annotate nullable elements with <code>@Nullable</code>. This dependency, like JSR305/javax-extras, is <code>compileOnly</code>.</p>"},{"location":"changelog/#misc-changes","title":"Misc changes","text":"<ul> <li>A few miscellaneous IDE warnings (#208)</li> <li>We are now building against Android Gradle Plugin 3.1.x (latest stable) (#190)</li> <li>Due to ongoing Dokka issues and update latency, we\u2019ve had to disable it on Kotlin artifacts for   now. We plan to re-enable on the next release, which should add compatibility for AGP 3.x+.</li> </ul>"},{"location":"changelog/#call-for-input-on-next-steps","title":"Call for input on next steps","text":"<p>We have two major design proposals that we want community feedback on that would take shape in the next couple of releases. Please let us know if you have any thoughts!</p> <ul> <li>Kotlin rewrite: #198</li> <li>Extract LifecycleScopeProvider to separate artifact, make it extend ScopeProvider: #197</li> </ul> <p>Thanks to the following contributors for this release: @tbsandee, @atexannamedbob</p>"},{"location":"changelog/#version-070","title":"Version 0.7.0","text":"<p>2018-3-26</p>"},{"location":"changelog/#autodisposeandroidplugins-183","title":"AutoDisposeAndroidPlugins (#183)","text":"<p>New API! <code>AutoDisposeAndroidPlugins</code> API for plugin hooks to AutoDispose\u2019s android behavior at runtime. The first plugin supported here is <code>MainThreadChecker</code>.</p> <p>This plugin allows for supplying a custom <code>BooleanSupplier</code> that can customize how main thread checks work. The conventional use case of this is Android JUnit tests, where the <code>Looper</code> class is not stubbed in the mock android.jar and fails explosively when touched.</p> <p>Another potential use of this at runtime to customize checks for more fine-grained main thread checks behavior.</p> <p>Example</p> <pre><code>AutoDisposeAndroidPlugins.setOnCheckMainThread(() -&gt; {\nreturn true; // Use whatever heuristics you prefer.\n})\n</code></pre> <p>This is available in the <code>autodispose-android</code> artifact, and all mainthread-checking APIs in android artifacts will delegate to this plugin hook.</p>"},{"location":"changelog/#misc_3","title":"Misc","text":"<ul> <li>Fixed a few nullability and other minor warnings (#187)</li> <li>Contributed by @tbsandee!</li> </ul>"},{"location":"changelog/#version-061","title":"Version 0.6.1","text":"<p>2018-2-23</p> <p>This is patch release with a couple of QoL improvements: * Android artifacts\u2019 consumer proguard rules have been updated to not warn on the compiled error-prone annotations, like <code>@DoNotMock</code> (#178)   * Contributed by @danh32! * Android artifacts no longer bundle a useless <code>BuildConfig.java</code> file (#177)</p>"},{"location":"changelog/#version-060","title":"Version 0.6.0","text":"<p>2018-2-5</p>"},{"location":"changelog/#error-prone-checker-artifact-156","title":"Error-Prone Checker artifact (#156)","text":"<p>There is a new Error-Prone checker artifact that you can optionally apply to have error-prone enforced checks that rx chains are autodisposed when executing in a class that has scope. This is experimental in the public, but has been used extensively internally at Uber for nearly a year. Please let us know if you run into any issues!</p> <p>Wiki page with setup and configuration instructions: https://github.com/uber/AutoDispose/wiki/Error-Prone-Checker</p> <p>We plan to add a UAST lint artifact in the future as well.</p>"},{"location":"changelog/#parallelflowable-support-155","title":"ParallelFlowable support (#155)","text":"<p>AutoDispose now supports RxJava\u2019s <code>ParallelFlowable</code> type. Note that this only works through the new <code>as()</code> API, and there is no <code>ParallelScoper</code> API (since those are being removed in 1.0).</p>"},{"location":"changelog/#scopeprovider-and-lifecyclescopeprovider-are-now-annotated-with-donotmock-153","title":"ScopeProvider and LifecycleScopeProvider are now annotated with <code>@DoNotMock</code> (#153)","text":"<p>These types have specific test helpers that will be more robust for long term test usage, and thus should not be mocked.</p>"},{"location":"changelog/#convenience-test-methods-added-to-all-subscribeproxy-interfaces-160","title":"Convenience <code>test()</code> methods added to all SubscribeProxy interfaces (#160)","text":"<p>These are to match the convenience <code>test()</code> methods in regular RxJava types.</p>"},{"location":"changelog/#misc_4","title":"Misc","text":"<ul> <li>Archcomponents updated to 1.1.0 for compatibility with new artifacts (#128)</li> <li><code>autodispose-android-archcomponents-test</code> and <code>autodispose-android-archcomponents-test-kotlin</code> now only depend on the <code>common</code> arch components artifact rather than <code>extensions</code>, which removes the unused <code>livedata</code> and <code>viewmodel</code> transitive dependencies.</li> <li>RxViewHolder examples now implement <code>LifecycleScopeProvider</code> instead of <code>ScopeProvider</code> (#157)</li> <li>Deprecated Kotlin APIs are now <code>ERROR</code> level instead of <code>WARNING</code> (#151)</li> <li>Various doc fixes (#158)</li> <li>RxLifecycle updated to 2.2.1 (#161)</li> <li>ErrorProne annotations updated to 2.2.0 (#161)</li> <li>Android artifacts now compiled against SDK 27</li> <li>Android support annotations updated to 27.0.2</li> </ul> <p>Thanks to the following contributors! @VisheshVadhera @bangarharshit @mmallozzi @0legg @shaunkawano</p>"},{"location":"changelog/#version-051","title":"Version 0.5.1","text":"<p>2017-12-6</p> <p>Fix: A bug where unbound scopes would mark the observer as disposed, subsequently preventing future events from emitting. (#149)</p> <p>Fix: Kotlin docs accidentally pointing to <code>to()</code> operators instead of <code>as()</code>. (#145)</p> <p>Snapshots should be fully working now as well.</p>"},{"location":"changelog/#version-050","title":"Version 0.5.0","text":"<p>2017-12-3</p>"},{"location":"changelog/#new-converter-based-api-for-use-with-as-141","title":"New converter-based API for use with as() (#141)","text":"<p>AutoDispose\u2019s primary API is now via static <code>autoDisposable()</code> methods on the <code>AutoDispose</code> class. The previous <code>to()</code> based APIs are now completely deprecated, and will be removed in AutoDispose 1.0.</p> <p>This has been sort of the long-standing ideal API for AutoDispose for awhile, but wasn\u2019t possible until the introduction of the new <code>as()</code> operator in RxJava. As this operator is still not marked as stable (and won\u2019t until RxJava 2.2.0), AutoDispose will not be updated to 1.0 until then.</p> <p>The main difference is that you no longer have to specify the type indirection, and the returned converter is applicable for all 5 RxJava types. In use, it looks like this:</p> <pre><code>Flowable.just(1)\n.as(autoDisposable(scope))\n.subscribe()\n\nObservable.just(1)\n.as(autoDisposable(scope))\n.subscribe()\n\nMaybe.just(1)\n.as(autoDisposable(scope))\n.subscribe()\n\nSingle.just(1)\n.as(autoDisposable(scope))\n.subscribe()\n\nCompletable.complete()\n.as(autoDisposable(scope))\n.subscribe()\n</code></pre> <p>There are three overloads for <code>autoDisposable()</code>, for each of the three scope types (<code>Maybe</code>, <code>ScopeProvider</code>, and <code>LifecycleScopeProvider</code>).</p> <p>The Kotlin bindings have also been updated to match semantics, with the <code>autoDisposeWith</code> extension functions being deprecated in favor of analogous <code>autoDisposable</code>. These are <code>WARNING</code> level in this release, and will become <code>ERROR</code> in AutoDispose 0.6.0, before finally being removed in 1.0. They also provide <code>replaceWith</code> options (compatible with Kotlin\u2019s deprecation quickfixes).</p> <p><code>autoDisposable</code> reads best when statically imported (so you can do <code>.as(autoDisposable(...))</code>, which you can safely do if you\u2019re using Java 8.</p> <p>For structural replace templates, see here).</p>"},{"location":"changelog/#fixed-a-lot-of-concurrency-edge-cases-and-performance-improvements-after-review-from-david-karnok-138-and-130","title":"Fixed a lot of concurrency edge cases and performance improvements after review from David Karnok (#138 and #130)","text":"<p>David Karnok (@akarnokd, RxJava project lead) did an audit of the current codebase and gave extensive feedback in #130. #138 implements that feedback. This handled a lot of concurrency gotchas and edge cases we were missing before. See the issue and PR for full details.</p>"},{"location":"changelog/#plugin-for-controlling-whether-or-not-to-fill-in-stacktraces-124","title":"Plugin for controlling whether or not to fill in stacktraces (#124)","text":"<p><code>AutoDisposePlugins</code> has a new API to control whether or not lifecycle exception stacktraces are filled in. What this means is that if you opt out, the exceptions thrown in <code>LifecycleScopeProvider</code> boundary issues will no longer have a stacktrace (<code>getStacktrace()</code> will return an empty array) and only carry the type name and message. This can be useful to gain some performance if you track stacktracing via other means.</p>"},{"location":"changelog/#unbound-shorthand-125","title":"UNBOUND shorthand (#125)","text":"<p><code>ScopeProvider</code> has a static instance of an \u201cunbound\u201d provider directly in the interface now for reuse. This obviates the need for <code>TestScopeProvider#unbound()</code>, which has been removed. Usage is simple:</p> <pre><code>Observable.just(1)\n.as(autoDisposable(ScopeProvider.UNBOUND))\n.subscribe()\n</code></pre>"},{"location":"changelog/#misc_5","title":"Misc","text":"<ul> <li>Archcomponents updated to 1.0.0 final (#128)</li> <li>RxJava dependency is now 2.1.7 (to leverage <code>as()</code>) (#141)</li> <li>Kotlin is now updated to 1.2.0 (#141)</li> <li>Dokka is wired up, meaning that kotlin artifacts now also have exported javadocs. (#126)</li> <li><code>subscribeBy</code> example extension in the sample app displaying how you can add extension functions to the <code>*SubscribeProxy</code> classes. (#127)</li> <li><code>delegateObserver()</code> APIs on <code>AutoDisposing</code> observers have been promoted to stable. Considering they are useful for <code>subscribeWith()</code>, we can just keep it observer-based and keep the library more flexible long-term (#144)</li> </ul> <p>Thanks to the following contributors! @charlesdurham @ajalt @tbsandee @akarnokd</p>"},{"location":"changelog/#version-040","title":"Version 0.4.0","text":"<p>2017-10-22</p>"},{"location":"changelog/#structured-android-components-111","title":"Structured Android Components #111","text":"<p>Android components have been split up into several artifacts under <code>:android</code>: -  <code>autodispose-android</code>: Core android utilities, previously <code>:autodispose-android</code> - <code>autodispose-android-archcomponents</code>: Utilities for lifecycles in android archcomponents, previously <code>:autodispose-android-archcomponents</code> but does not have the test helper - New: <code>autodispose-android-archcomponents-test</code>: Test utilities for working with arch components, namely <code>TestLifecycleOwner</code>, formerly <code>TestAndroidLifecycleScopeProvider</code>.   - This allows us to remove the <code>extensions</code> dependency from the main arch components artifact and keep this optional. This API can also be used for general use testing for arch components, as it\u2019s not actually specific to AutoDispose. - New: <code>autodispose-android-kotlin</code>: kotlin bindings for <code>autodispose-android</code> - New: <code>autodispose-android-archcomponents-kotlin</code>: kotlin bindings for <code>autodispose-android-archcomponents</code> - New: <code>autodispose-android-archcomponents-test-kotlin</code>: kotlin bindings for <code>autodispose-android-test-archcomponents</code> - New: Android artifacts include consumer proguard rules (relates to (#112))</p> <p>Related changes: - Fix: Arch components updated to <code>1.0.0-rc1</code>, which should fix compatibility issues noted in (#113) - Enhancement: <code>untilEvent</code> overload for AndroidLifecycleScopeProvider (#107)   - Now you can bind until a specific target event, or provide your own boundary provider function - Behavior change: previously, anything occurring after <code>ON_STOP</code> would resolve to <code>ON_DESTROY</code>. Now, they resolve to stop on the next destruction event. This brings it inline with the modern behavior of arch components version <code>-rc1</code>. - Enhancement: <code>AndroidLifecycleScopeProvider</code>s are now reusable. This is somewhat experimental, as it works by dynamically resolving the last event based on the state. Please report any issues! #121</p>"},{"location":"changelog/#rxlifecycle-interop","title":"RxLifecycle Interop","text":"<p>A new <code>autodispose-rxlifecycle</code> interop module was added, adding support for scoping to RxLifecycle\u2018s <code>LifecycleProvider</code> API. (#118)</p>"},{"location":"changelog/#misc_6","title":"Misc","text":"<ul> <li>Reduced object allocations (#108)</li> <li>Convenience <code>unbound()</code> factory on <code>TestScopeProvider</code> (#108)</li> <li>Removed synthetic accessors (#103)</li> <li>Updated to Kotlin 1.1.51 (#116)</li> </ul> <p>Thanks to the following contributors! @rubengees @bangarharshit</p>"},{"location":"changelog/#updated-dependencies","title":"Updated dependencies:","text":"<pre><code>Android Arch Components: 1.0.0-rc1\nAndroid Arch Components (common): 1.0.3\nKotlin: 1.1.51\n</code></pre>"},{"location":"changelog/#new-artifacts-coordinates","title":"New artifacts coordinates:","text":"<p> <pre><code>compile 'com.uber.autodispose:autodispose-android-archcomponents-test:x.y.z'\n</code></pre></p> <p> <pre><code>compile 'com.uber.autodispose:autodispose-rxlifecycle:x.y.z'\n</code></pre></p> <p> <pre><code>compile 'com.uber.autodispose:autodispose-android-kotlin:x.y.z'\n</code></pre></p> <p> <pre><code>compile 'com.uber.autodispose:autodispose-android-archcomponents-kotlin:x.y.z'\n</code></pre></p> <p> <pre><code>compile 'com.uber.autodispose:autodispose-android-archcomponents-test-kotlin:x.y.z'\n</code></pre></p>"},{"location":"changelog/#version-030","title":"Version 0.3.0","text":"<p>2017-10-01</p> <ul> <li>New: Static factory API (#88)</li> </ul> <p>After a long time trying to figure out how to finagle this in a way that played nice with IDE autocomplete, the main API for AutoDispose is now via the <code>AutoDispose</code> class and its static factories.</p> <pre><code>Observable(1)\n.to(AutoDispose.with(yourScope).forObservable())\n.subscribe();\n\n// Note: on Java 7, you must specify the generic. The IDE should autocomplete this for you.\nObservable(1)\n.to(AutoDispose.with(yourScope).&lt;Integer&gt;forObservable())\n.subscribe();\n</code></pre> <p><code>with()</code> has three overloads for <code>Maybe</code>, <code>ScopeProvider</code>, and <code>LifecycleScopeProvider</code>. They return an intermediary <code>ScopeHandler</code>, which in turn has 5 generic <code>for___()</code> methods that correspond to the 5 RxJava types (<code>Observable</code>, <code>Flowable</code>, <code>Single</code>, <code>Maybe</code>, and <code>Completable</code>).</p> <p>The old <code>Scoper</code> class are now deprecated, and will be removed in AutoDispose 1.0. Fortunately, this is easy to migrate via IntelliJ\u2019s structural replace. Information can be found here.</p> <ul> <li>New: Support for Android Architecture Components! (#71)</li> </ul> <p>With the beta release of architecture components, they are now supported in the <code>autodispose-android-archcomponents</code> artifact.</p> <pre><code>Observable(1)\n.to(AutoDispose.with(AndroidLifecycleScopeProvider.from(this)).forObservable())\n.subscribe();\n</code></pre> <p>Where <code>this</code> could be anything that implements <code>LifecycleOwner</code> or extends <code>Lifecycle</code>.</p> <p> <pre><code>compile 'com.uber.autodispose:autodispose-android-archcomponents:x.y.z'\n</code></pre></p> <p>Thanks to @yigit, @jaychang0917, and @lsvijay for their help and contributions on this!</p> <ul> <li>New: Delegate Observer retrieval (#89)</li> </ul> <p>Every automatically disposing observer implements one of the corresponding <code>AutoDisposing____Observer</code> interfaces in the <code>com.uber.autodispose.observers</code> package. They are considered read-only public API, with the intention that you can look for them in the RxJava plugin system (such as an onSubscribe hook). This extends their functionality to expose a new experimental API called <code>delegateObserver()</code>. This allows you to access the underlying observer that this is automatically disposing.</p> <p>The reason for this is that there may be conditions where you want to handle functionality depending on information from that Observer. As of RxJava 2.1.4, one such case could be to read information from a <code>LambdaConsumerIntrospection</code> (relevant PR).</p> <p>In the future, this will likely be narrowed to return a <code>@Nullable lambdaConsumerIntrospection()</code>, but we\u2019re open to feedback if others think this should remain the high level <code>Observer</code> type.</p> <p>Thanks to @mswysocki for his contribution on this!</p> <ul> <li>New: JSR 305 Nullability Annotations (#79)</li> </ul> <p>AutoDispose packages now leverage JSR 305 annotations to indicate nullability. By default, all methods and parameters are non-null by default. This uses the spin-off javax-extras artifact for method nullability support, and is only a <code>compileOnly</code> dependency (so it should show up) for tooling but is not packaged as a compile dependency.</p> <p>Further reading: https://medium.com/square-corner-blog/non-null-is-the-default-58ffc0bb9111</p> <ul> <li>New: Sample android app! (#97)</li> </ul> <p>For a long time, AutoDispose relied on tests and the README to be demonstrations of API use. It\u2019s become clear that this is not enough information though, so we\u2019ve added a full sample app (borrowing heavily from RxLifecycle/Conductor\u2019s) to better illustrate API usage and runtime behavior. We\u2019ll continue to iterate on this over time.</p> <ul> <li>Improved: EndConsumerHelper (#77)</li> </ul> <p>AutoDispose uses the same disposal-helper utilities as RxJava. This updates to RxJava\u2019s new <code>EndConsumerHelper</code>, which should hopefully help produce more helpful error messages in disposal error conditions.</p> <ul> <li>Other</li> </ul> <p>Updated various dependencies:</p> <pre><code>Android Arch Components: 1.0.0-beta1\nAndroid Support Library: 26.1.0 (to match arch components)\nKotlin: 1.1.50\n</code></pre> <p>As always, we welcome any and all discussions/feedback/PRs! We\u2019re marching toward a 1.0 release Real Soon Now, so now is the time. There are a few outstanding discussion issues in the issue tracker about 1.0 final design decisions.</p>"},{"location":"changelog/#version-020","title":"Version 0.2.0","text":"<p>2017-05-08</p> <ul> <li>New: Kotlin artifact! (#47)</li> </ul> <p>This adds <code>autoDisposeWith()</code> extensions to RxJava types.</p> <pre><code>myObservable\n.doWhatever()\n.autoDisposeWith(this)\n.subscribe()\n</code></pre> <ul> <li>New: Plugin system! (#57)</li> </ul> <p>Modeled after RxJava\u2019s plugins, this allows you to customize the behavior of AutoDispose with lifecycle boundary checks.</p> <pre><code>AutoDisposePlugins.setOutsideLifecycleHandler(t -&gt; {\n// Swallow the exception, or rethrow it, or throw your own!\n})\n</code></pre> <p>A good use case of this is, say, just silently disposing/logging observers outside of lifecycle exceptions in production but crashing on debug.</p> <ul> <li>New: Test helpers! (#48 #49)</li> </ul> <p>Two helpers were added to simulate conditions in testing. - <code>TestLifecycleScopeProvider</code>   - This has two corresponding lifecycle methods: <code>start()</code> and <code>stop()</code> - <code>TestScopeProvider</code>   - Has just one method - <code>emit()</code>.</p> <p>For testing with just the <code>Maybe&lt;?&gt;</code> scope, we recommend using RxJava\u2019s built-in <code>MaybeSubject</code>.</p> <ul> <li>Fix: Fixed a race condition where upstream wouldn\u2019t be disposed if the lifecycle emitted or error\u2019d synchronously (i.e. was already terminated). (#57)</li> <li>Fix: Add missing <code>@CheckReturnValue</code> annotations to <code>subscribeWith</code> methods. (#53)</li> </ul> <p>Other tidbits: - Removed <code>@NonNull</code> annotations. Everything is <code>@NonNull</code> by default, and only elements annotated with <code>@Nullable</code> are not. - Use of the new <code>java-library</code> plugin for gradle (#64). The RxJava dependencies are marked as <code>api</code>. - Error prone has been integrated. Currently the annotations are just marked as <code>compileOnly</code>, but if a need arises/community wants them - we can compile them in a future version.</p>"},{"location":"changelog/#version-010","title":"Version 0.1.0","text":"<p>2017-03-13</p> <ul> <li>Initial release</li> </ul>"},{"location":"code-of-conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"code-of-conduct/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"code-of-conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others\u2019 private information, such as a physical or electronic address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"code-of-conduct/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"code-of-conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"code-of-conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at mobile-open-source@uber.com. The project team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p> <p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project\u2019s leadership.</p>"},{"location":"code-of-conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at https://contributor-covenant.org/version/\u00bc</p>"},{"location":"contributing/","title":"Contributing to AutoDispose","text":"<p>The Uber team welcomes contributions of all kinds, from simple bug reports through documentation, test cases, bugfixes, and features.</p>"},{"location":"contributing/#workflow","title":"Workflow","text":"<p>We love GitHub issues!</p> <p>For small feature requests, an issue first proposing it for discussion or demo implementation in a PR suffice.</p> <p>For big features, please open an issue so that we can agree on the direction, and hopefully avoid investing a lot of time on a feature that might need reworking.</p> <p>Small pull requests for things like typos, bugfixes, etc are always welcome.</p>"},{"location":"contributing/#code-style","title":"Code style","text":"<p>This project uses ktlint and GJF, provided via the spotless gradle plugin.</p> <p>If you find that one of your pull reviews does not pass the CI server check due to a code style conflict, you can easily fix it by running: ./gradlew spotlessApply.</p> <p>Generally speaking - we use vanilla ktlint + 2space indents, and vanilla GJF. You can integrate both of these in IntelliJ code style via either GJF\u2019s official plugin or applying code style from Jetbrains\u2019 official style.</p> <p>No star imports please!</p>"},{"location":"contributing/#dos-and-donts","title":"DOs and DON\u2019Ts","text":"<ul> <li>DO follow our coding style</li> <li>DO include tests when adding new features. When fixing bugs, start with adding a test that highlights how the current behavior is broken.</li> <li>DO keep the discussions focused. When a new or related topic comes up it\u2019s often better to create new issue than to side track the discussion.</li> <li> <p>DO run all Gradle verification tasks (<code>./gradlew check</code>) before submitting a pull request</p> </li> <li> <p>DON\u2019T submit PRs that alter licensing related files or headers. If you believe there\u2019s a problem with them, file an issue and we\u2019ll be happy to discuss it.</p> </li> </ul>"},{"location":"error-prone/","title":"Error Prone","text":"<p><code>AutoDispose</code> is an Error-Prone check to detect missing AutoDispose scope within defined scoped elements.</p>"},{"location":"error-prone/#installation","title":"Installation","text":"<p>Below are sample configurations which pull in both the AutoDispose Error-Prone checker.</p>"},{"location":"error-prone/#gradle","title":"Gradle","text":""},{"location":"error-prone/#java","title":"Java","text":"<pre><code>plugins {\n  id \"java-library\" // Or whatever other java plugin you're using\n  id \"net.ltgt.errorprone\" version \"0.6\"\n}\n\ndependencies {\n  errorprone \"com.uber.autodispose:autodispose-error-prone:x.y.z\" // where x.y.z is the latest version.\n  errorprone \"com.google.errorprone:error_prone_core:2.3.2\" // Or whatever the latest version is\n}\n\ntasks.withType(JavaCompile).configureEach {\n  // Only if you want to support custom types with scopes\n  // Below is a sample configuration which includes Conductor\n  def classesWithScope = [\n      \"com.bluelinelabs.conductor.Controller\"\n  ]\n  options.errorprone {\n    check(\"AutoDispose\", CheckSeverity.ERROR)\n    option(\"AutoDispose:TypesWithScope\", classesWithScope.join(\",\"))\n    option(\"UAutoDispose:Lenient\", \"true\")\n  }\n}\n</code></pre>"},{"location":"error-prone/#android","title":"Android","text":"<pre><code>plugins {\n  id \"net.ltgt.errorprone\" version \"0.0.13\"\n}\n\ndependencies {\n  errorprone \"com.uber.autodispose:autodispose-error-prone-checker:x.y.z\" // where x.y.z is the latest version.\n  errorprone \"com.google.errorprone:error_prone_core:2.3.2\" // Or whatever the latest version is\n}\n\n// Must go in afterEvaluate\nafterEvaluate {\n  tasks.withType(JavaCompile).configureEach {\n    // Only if you want to support custom types with scopes\n    // Below is a sample configuration which includes Conductor\n    def classesWithScope = [\n        \"com.bluelinelabs.conductor.Controller\"\n    ]\n    options.errorprone {\n      check(\"AutoDispose\", CheckSeverity.ERROR)\n      option(\"AutoDispose:TypesWithScope\", classesWithScope.join(\",\"))\n      option(\"AutoDispose:Lenient\", \"true\")\n    }\n  }\n}\n</code></pre>"},{"location":"error-prone/#maven","title":"Maven","text":"<pre><code>&lt;build&gt;\n&lt;plugins&gt;\n&lt;plugin&gt;\n&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n&lt;version&gt;3.5&lt;/version&gt;\n&lt;configuration&gt;\n&lt;compilerId&gt;javac-with-errorprone&lt;/compilerId&gt;\n&lt;forceJavacCompilerUse&gt;true&lt;/forceJavacCompilerUse&gt;\n&lt;source&gt;1.8&lt;/source&gt;\n&lt;target&gt;1.8&lt;/target&gt;\n&lt;showWarnings&gt;true&lt;/showWarnings&gt;\n&lt;annotationProcessorPaths&gt;\n&lt;path&gt;\n&lt;groupId&gt;com.uber.autodispose&lt;/groupId&gt;\n&lt;artifactId&gt;autodispose-error-prone&lt;/artifactId&gt;\n&lt;version&gt;x.y.z&lt;/version&gt;\n&lt;/path&gt;\n&lt;/annotationProcessorPaths&gt;\n&lt;compilerArgs&gt;\n&lt;!-- Only if you want to support custom configuration\n          Below is a sample configuration which includes Conductor --&gt;\n&lt;arg&gt;--XepOpt:AutoDispose:TypesWithScope=com.bluelinelabs.conductor.Controller&lt;/arg&gt;\n&lt;arg&gt;--XepOpt:AutoDispose:Lenient=true&lt;/arg&gt;\n&lt;/compilerArgs&gt;\n&lt;/configuration&gt;\n&lt;dependencies&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;org.codehaus.plexus&lt;/groupId&gt;\n&lt;artifactId&gt;plexus-compiler-javac-errorprone&lt;/artifactId&gt;\n&lt;version&gt;2.8&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;!-- override plexus-compiler-javac-errorprone's dependency on\n             Error Prone with the latest version --&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;com.google.errorprone&lt;/groupId&gt;\n&lt;artifactId&gt;error_prone_core&lt;/artifactId&gt;\n&lt;version&gt;2.3.2&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;/dependencies&gt;\n&lt;/plugin&gt;\n&lt;/build&gt;\n</code></pre>"},{"location":"error-prone/#report-example","title":"Report example","text":"<p>The following code snippet:</p> <pre><code>public class ComponentWithLifecycle extends Activity {\npublic void observeOnSomething() {\nObservable\n.interval(1, TimeUnit.SECONDS)\n.subscribe(new Consumer&lt;Long&gt;() {\n@Override public void accept(Long interval) throws Exception {\nSystem.out.println(interval);\n}\n});\n}\n}\n</code></pre> <p>would produce the following error:</p> <pre><code>./gradlew build\nerror: [AutoDispose] Missing Disposable handling: Apply AutoDispose or cache the Disposable instance manually and enable lenient mode.\n        .subscribe(new Consumer&lt;Long&gt;() {\n                  ^\n    (see https://github.com/uber/AutoDispose/wiki/Error-Prone-Checker)\n</code></pre> <p>Would lead to this error at compile-time.</p>"},{"location":"error-prone/#configuration","title":"Configuration","text":""},{"location":"error-prone/#scopes","title":"Scopes","text":"<p>By default the checker is applied to AutoDispose interfaces and standard Android components with lifecycles: 1. Activity 2. Fragment 3. Support Fragment 4. LifecycleScopeProvider 5. ScopeProvider 6. LifecycleOwner</p> <p>This can be configured by Error-Prone\u2019s command line flags. The following flag is supported and takes input in a form of comma separated list of fully qualified class names of classes with scopes:</p> <pre><code>-XepOpt:AutoDispose:TypesWithScope=com.bluelinelabs.conductor.Controller,android.app.Activity\n</code></pre> <p>This flag adds the provided custom scopes to the default scopes mentioned above.</p>"},{"location":"error-prone/#overriding-scopes","title":"Overriding Scopes","text":"<p>If you only want the error prone check to run on your custom scopes and not the default ones, you can simply override the default scopes by adding the <code>OverrideScopes</code> flag like so: <pre><code>-XepOpt:AutoDispose:OverrideScopes=true\n</code></pre></p>"},{"location":"error-prone/#lenient","title":"Lenient","text":"<p><code>Lenient</code> is a mode to ask the checker to be lenient when capturing returned <code>Disposable</code> types. What this means is that if an rx <code>subscribe</code> method is called and its returned <code>Disposable</code> is captured, AutoDispose this code is manually managing the subscription and show ignore it. The same applies for capturing the returned value of <code>subscribeWith</code> if the input type implements <code>Disposable</code>.</p> <p>This can be configured by Error-Prone\u2019s command line flags. The following flag is supported and takes input in a form of a boolean <code>true</code> or <code>false</code>:</p> <pre><code>-XepOpt:AutoDispose:Lenient=true\n</code></pre> <p>The default value of this is <code>false</code>.</p> <p>Examples</p> <pre><code>// This is allowed in lenient mode\nDisposable d = Observable.just(1).subscribe();\n\n// This is allowed in lenient mode, because the subscribeWith arg type is Disposable\nDisposableObserver&lt;Integer&gt; do = Observable.just(1).subscribeWith(new DisposableObserver...)\n\n// This is not allowed in lenient mode, because the subscribeWith arg type is not Disposable\nObserver&lt;Integer&gt; do = Observable.just(1).subscribeWith(new Observer...)\n\n// This is not allowed in lenient mode, because the return value is not captured\nObservable.just(1).subscribe();\n\n// This is not allowed in lenient mode, because that subscribe() overload just returns void\nObservable.just(1).subscribe(new Observer...)\n</code></pre>"},{"location":"lint-check/","title":"Lint Check","text":"<p><code>AutoDisposeDetector</code> is a lint check to detect missing AutoDispose scope within defined scoped elements.</p>"},{"location":"lint-check/#installation","title":"Installation","text":"<p>For Android Java/Kotlin projects, no configuration is required as the AutoDispose lint check is run by default with the existing lint checks.</p> <p>For pure JVM projects, apply the <code>com.android.lint</code> plugin and add the lint dependency to the <code>lintChecks</code> configuration.</p> <pre><code>plugins {\nid \"org.jetbrains.kotlin.jvm\"\nid \"com.android.lint\"\n}\n\ndependencies {\nlintChecks \"com.uber.autodispose2:autodispose-lint:&lt;version&gt;\"\n}\n</code></pre>"},{"location":"lint-check/#report-example","title":"Report example","text":"<p>The following code snippet: <pre><code>class ComponentWithLifecycle : Activity {\n\nfun observeOnSomething() {\nObservable\n.interval(1, TimeUnit.SECONDS)\n.subscribe { println(it) }\n}\n}\n</code></pre> will produce the following error at compile-time: <pre><code>./gradlew build\nsrc/com/sample/app/ComponentWithLifecycle.kt:5: Error: Missing Disposable handling: Apply AutoDispose or cache the Disposable instance manually and enable lenient mode. [AutoDispose]\n        .subscribe { println(it) }\n        ~~~~~~~~~~~~~~~~~~~~~~~~~~\n1 errors, 0 warnings\n</code></pre></p>"},{"location":"lint-check/#configuration","title":"Configuration","text":""},{"location":"lint-check/#scopes","title":"Scopes","text":"<p>By default, the lint check is applied to AutoDispose interfaces and standard Android components with lifecycles: 1. Activity 2. Fragment 3. Support Fragment 4. ScopeProvider (which implicitly includes LifecycleScopeProvider) 5. LifecycleOwner</p> <p>You can add your own custom scopes that you want the lint check applied to. In your app-level <code>gradle.properties</code> file, add the fully qualified name of your custom classes as comma-separated-values like so: <pre><code>autodispose.typesWithScope=com.bluelinelabs.conductor.Controller,com.sample.app.BasePresenter\n</code></pre> The types supplied are then added to the default types listed above.</p>"},{"location":"lint-check/#overriding-scopes","title":"Overriding Scopes","text":"<p>If you only want the lint check to run on your custom scopes and not the default ones, you can simply override the default scopes by adding this in your app-level <code>gradle.properties</code> file: <pre><code>autodispose.overrideScopes=true\n</code></pre></p>"},{"location":"lint-check/#lenient","title":"Lenient","text":"<p><code>Lenient</code> is a mode to ask the checker to be lenient when capturing returned Disposable types. What this means is that if an rx subscribe method is called and its returned Disposable is captured, AutoDispose this code is manually managing the subscription and show ignore it. The same applies for capturing the returned value of subscribeWith if the input type implements Disposable.</p> <p>This can be configured by adding the following flag to the app-level <code>gradle.properties</code> file. <pre><code>autodispose.lenient=true\n</code></pre></p> <p>The default value of this is <code>false</code>.</p>"},{"location":"lint-check/#kotlin-extension","title":"Kotlin Extension","text":"<p>By default, <code>subscribe</code> and <code>subscribeWith</code> methods are checked. To support other subscribe methods such as <code>subscribeBy</code> in RxKotlin, you can add your own subscribe extensions. In your app-level <code>gradle.properties</code> files, add kotlin extension functions in format of <code>{full package name for extension's scope}#{functionName}</code> and comma-separated-values like so:</p> <pre><code>autodispose.kotlinExtensionFunctions=\"io.reactivex.rxjava3.kotlin.subscribers#subscribeBy,com.sample.app.SubscribeExt#subscribe2\"\n</code></pre>"},{"location":"lint-check/#examples","title":"Examples","text":"<pre><code>// This is allowed in lenient mode\nDisposable d = Observable.just(1).subscribe();\n\n// This is allowed in lenient mode, because the subscribeWith arg type is Disposable\nDisposableObserver&lt;Integer&gt; do = Observable.just(1).subscribeWith(new DisposableObserver...)\n\n// This is not allowed in lenient mode, because the subscribeWith arg type is not Disposable\nObserver&lt;Integer&gt; do = Observable.just(1).subscribeWith(new Observer...)\n\n// This is not allowed in lenient mode, because the return value is not captured\nObservable.just(1).subscribe();\n\n// This is not allowed in lenient mode, because that subscribe() overload just returns void\nObservable.just(1).subscribe(new Observer...)\n\n// This is not allowed when kotlin extension functions option is used\nObservable.just(1).subscribeBy { }\n</code></pre>"},{"location":"migrating-020-030/","title":"Migrating from 0.2.0 to 0.3.0","text":"<p>0.3.0 switched the API to the new static factories in <code>AutoDispose.java</code>. To migrate, you can leverage IntelliJ\u2019s structural replace. Below is an exhaustive list. I suspect this could be whittled down to <code>Completable</code> replacement and java \u215e generic templates, but my script text fu isn\u2019t good enough (contributions welcome!).</p> <p>Notes for structural replace. If using Java 8, replace <code>&lt;$Type$&gt;</code> with <code>&lt;&gt;</code> and remove <code>&lt;$Type&gt;</code> from the replacement template. Would be ideal to combine these into one smart replace but the tooling is a little rough to debug.</p>"},{"location":"migrating-020-030/#flowable","title":"Flowable","text":""},{"location":"migrating-020-030/#java-8-object-streams","title":"Java 8 / <code>Object</code> streams","text":"<p>Search template <pre><code>$Stream$.to(new com.uber.autodispose.FlowableScoper&lt;&gt;($Scope$))\n</code></pre> Replacement template <pre><code>$Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).forFlowable())\n</code></pre></p>"},{"location":"migrating-020-030/#java-7-regular-types","title":"Java 7 regular types","text":"<p>Search template <pre><code>$Stream$.to(new com.uber.autodispose.FlowableScoper&lt;$Type$&gt;($Scope$))\n</code></pre> Replacement template <pre><code>$Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).&lt;$Type$&gt;forFlowable())\n</code></pre></p>"},{"location":"migrating-020-030/#observable","title":"Observable","text":""},{"location":"migrating-020-030/#java-8-object-streams_1","title":"Java 8 / <code>Object</code> streams","text":"<p>Search template <pre><code>$Stream$.to(new com.uber.autodispose.ObservableScoper&lt;&gt;($Scope$))\n</code></pre> Replacement template <pre><code>$Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).forObservable())\n</code></pre></p>"},{"location":"migrating-020-030/#java-7-regular-types_1","title":"Java 7 regular types","text":"<p>Search template <pre><code>$Stream$.to(new com.uber.autodispose.ObservableScoper&lt;$Type$&gt;($Scope$))\n</code></pre> Replacement template <pre><code>$Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).&lt;$Type$&gt;forObservable())\n</code></pre></p>"},{"location":"migrating-020-030/#maybe","title":"Maybe","text":""},{"location":"migrating-020-030/#java-8-object-streams_2","title":"Java 8 / <code>Object</code> streams","text":"<p>Search template <pre><code>$Stream$.to(new com.uber.autodispose.MaybeScoper&lt;&gt;($Scope$))\n</code></pre> Replacement template <pre><code>$Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).forMaybe())\n</code></pre></p>"},{"location":"migrating-020-030/#java-7-regular-types_2","title":"Java 7 regular types","text":"<p>Search template <pre><code>$Stream$.to(new com.uber.autodispose.MaybeScoper&lt;$Type$&gt;($Scope$))\n</code></pre> Replacement template <pre><code>$Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).&lt;$Type$&gt;forMaybe())\n</code></pre></p>"},{"location":"migrating-020-030/#single","title":"Single","text":""},{"location":"migrating-020-030/#java-8-object-streams_3","title":"Java 8 / <code>Object</code> streams","text":"<p>Search template <pre><code>$Stream$.to(new com.uber.autodispose.SingleScoper&lt;&gt;($Scope$))\n</code></pre> Replacement template <pre><code>$Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).forSingle())\n</code></pre></p>"},{"location":"migrating-020-030/#java-7-regular-types_3","title":"Java 7 regular types","text":"<p>Search template <pre><code>$Stream$.to(new com.uber.autodispose.SingleScoper&lt;$Type$&gt;($Scope$))\n</code></pre> Replacement template <pre><code>$Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).&lt;$Type$&gt;forSingle())\n</code></pre></p>"},{"location":"migrating-020-030/#completable","title":"Completable","text":"<p>Search template <pre><code>$Stream$.to(new com.uber.autodispose.CompletableScoper($Scope$))\n</code></pre> Replacement template <pre><code>$Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).forCompletable())\n</code></pre></p>"},{"location":"migrating-040-050/","title":"Migrating from 0.4.0 to 0.5.0","text":"<p>0.5.0 switched the API to the new <code>autoDisposable()</code> static factories in <code>AutoDispose.java</code>. To migrate, you can leverage IntelliJ\u2019s structural replace. Below is an exhaustive list. I suspect this could be whittled down to <code>Completable</code> replacement and java \u215e generic templates, but my script text fu isn\u2019t good enough (contributions welcome!).</p> <p>Notes for structural replace. If using Java 8, replace <code>&lt;$Type$&gt;</code> with <code>&lt;&gt;</code> and remove <code>&lt;$Type&gt;</code> from the replacement template. Would be ideal to combine these into one smart replace but the tooling is a little rough to debug.</p>"},{"location":"migrating-040-050/#flowable","title":"Flowable","text":""},{"location":"migrating-040-050/#java-8-object-streams","title":"Java 8 / <code>Object</code> streams","text":"<p>Search template <pre><code>$Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).forFlowable())\n</code></pre> Replacement template <pre><code>$Stream$.as(com.uber.autodispose.AutoDispose.autoDisposable($Scope$))\n</code></pre></p>"},{"location":"migrating-040-050/#java-7-regular-types","title":"Java 7 regular types","text":"<p>Search template <pre><code>$Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).&lt;$Type$&gt;forFlowable())\n</code></pre> Replacement template <pre><code>$Stream$.as(com.uber.autodispose.AutoDispose.&lt;$Type$&gt;autoDisposable($Scope$))\n</code></pre></p>"},{"location":"migrating-040-050/#observable","title":"Observable","text":""},{"location":"migrating-040-050/#java-8-object-streams_1","title":"Java 8 / <code>Object</code> streams","text":"<p>Search template <pre><code>$Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).forObservable())\n</code></pre> Replacement template <pre><code>$Stream$.as(com.uber.autodispose.AutoDispose.autoDisposable($Scope$))\n</code></pre></p>"},{"location":"migrating-040-050/#java-7-regular-types_1","title":"Java 7 regular types","text":"<p>Search template <pre><code>$Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).&lt;$Type$&gt;forObservable())\n</code></pre> Replacement template <pre><code>$Stream$.as(com.uber.autodispose.AutoDispose.&lt;$Type$&gt;autoDisposable($Scope$))\n</code></pre></p>"},{"location":"migrating-040-050/#maybe","title":"Maybe","text":""},{"location":"migrating-040-050/#java-8-object-streams_2","title":"Java 8 / <code>Object</code> streams","text":"<p>Search template <pre><code>$Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).forMaybe())\n</code></pre> Replacement template <pre><code>$Stream$.as(com.uber.autodispose.AutoDispose.autoDisposable($Scope$))\n</code></pre></p>"},{"location":"migrating-040-050/#java-7-regular-types_2","title":"Java 7 regular types","text":"<p>Search template <pre><code>$Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).&lt;$Type$&gt;forMaybe())\n</code></pre> Replacement template <pre><code>$Stream$.as(com.uber.autodispose.AutoDispose.&lt;$Type$&gt;autoDisposable($Scope$))\n</code></pre></p>"},{"location":"migrating-040-050/#single","title":"Single","text":""},{"location":"migrating-040-050/#java-8-object-streams_3","title":"Java 8 / <code>Object</code> streams","text":"<p>Search template <pre><code>$Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).forSingle())\n</code></pre> Replacement template <pre><code>$Stream$.as(com.uber.autodispose.AutoDispose.autoDisposable($Scope$))\n</code></pre></p>"},{"location":"migrating-040-050/#java-7-regular-types_3","title":"Java 7 regular types","text":"<p>Search template <pre><code>$Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).&lt;$Type$&gt;forSingle())\n</code></pre> Replacement template <pre><code>$Stream$.as(com.uber.autodispose.AutoDispose.&lt;$Type$&gt;autoDisposable($Scope$))\n</code></pre></p>"},{"location":"migrating-040-050/#completable","title":"Completable","text":"<p>Search template <pre><code>$Stream$.to(com.uber.autodispose.AutoDispose.with($Scope$).forCompletable())\n</code></pre> Replacement template <pre><code>$Stream$.as(com.uber.autodispose.AutoDispose.autoDisposable($Scope$))\n</code></pre></p>"},{"location":"migrating-1x-2x/","title":"Migrating from 1.x to 2.x","text":"<p>Migrating from AutoDispose 1.x to 2.x</p> <p>AutoDispose 2.x is built against RxJava 3.x and is binary-compatible with AutoDispose 1.x and RxJava 2.x. As such - it has a different package name and maven group ID.</p>"},{"location":"migrating-1x-2x/#packaging","title":"Packaging","text":"Maven Group ID Package Name 1.x <code>com.uber.autodispose</code> <code>com.uber.autodispose</code> 2.x <code>com.uber.autodispose2</code> <code>autodispose2</code> <p>For any sub-packages, the above mapping should be used for those package prefix replacements as well.</p>"},{"location":"migrating-1x-2x/#changes","title":"Changes","text":"<ul> <li>All deprecated APIs in 1.x have been removed. This consisted exclusively of deprecated Kotlin <code>autoDisposable</code> extension functions that were deprecated in 1.4.0.</li> <li>The <code>autodispose-android-archcomponents*</code> artifacts have been renamed to to <code>autodispose-androidx-lifecycle*</code> to match the <code>androidx-lifecycle</code> library they correspond to.</li> <li>The lint and error prone checks have also been updated. We may look at consolidating these before 2.0 final is released if the community wants.</li> <li>At the time of writing, there is no RxLifecycle with RxJava 3 support yet, and as such there is no AutoDispose 2.x interop artifact for RxLifecycle. We can add this back if there\u2019s a new RxLifecycle release with RxJava 3.x support.</li> </ul>"}]}